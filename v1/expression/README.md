# Arazzo Expression Parser

The `arazzo-go/v1/expression` subpackage provides functionality for parsing Arazzo runtime expressions in Golang. This package includes components for lexical analysis, parsing, and abstract syntax tree (AST) generation.

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [Installation](#installation)
- [Usage](#usage)
- [Components](#components)
- [Runtime Expressions](#runtime-expressions)
- [Arazzo Runtime Expression Syntax](#arazzo-runtime-expression-syntax)
- [Contributing](#contributing)
- [License](#license)

## Introduction

[Arazzo Runtime Expressions](https://spec.openapis.org/arazzo/latest.html#runtime-expressions)
allows values to be defined based on information that will
be available within the HTTP message in an actual API call,
or within objects serialized from the Arazzo document such 
as [workflows](https://spec.openapis.org/arazzo/latest.html#workflow-object)
or [steps](https://spec.openapis.org/arazzo/latest.html#step-object).


## Installation

To install the package, use the following command:

```sh
go get github.com/bragdond/arazzo-go/v1/expression
```

## Usage

Here is a basic example of how to use the `arazzo-go/v1/expression` package:

```go
package main

import (
    "fmt"
    "github.com/bragdond/arazzo-go/v1/expression"
)

func main() {
	lexer := NewLexer("$request.header.x")
	tokens, err := lexer.Tokenize()
	if err != nil {
		panic(fmt.Sprintf("unexpected error: %v", err))
	}

	parser := NewParser(tokens)
	expr, err := parser.Parse()
	if err != nil {
		panic(fmt.Sprintf("unexpected error: %v", err))
	}

	printer := &ASTPrinter{}
	str := printer.Stringify(expr)
	fmt.Println(str)
    // Expected: ($request. (header. x))
}
```

## Components

The package consists of the following main components:

- **Lexer**: Responsible for lexical analysis of the input expression.
- **Parser**: Responsible for parsing tokens generated by the lexer and creating an AST.
- **AST**: Defines the structure of the abstract syntax tree.
- **ABNF**: Implements Augmented Backus-Naur Form (ABNF) rules for the expressions.

## Runtime Expressions

The following table provides examples of runtime expressions supported by the Arazzo Specification:

| Source Location | Example Expression | Notes |
|----------|----------|----------|
| HTTP Method            | `$method` | The allowable values for the `$method` will be those for the HTTP operation. |
| Requested media type   | `$request.header.accept` | |
| Request parameter      | `$request.path.id` | Request parameters MUST be declared in the `parameters` section of the parent operation or they cannot be evaluated. This includes request headers, path parameters, and query parameters. |
| Request body property  | `$request.body#/user/uuid` | In operations which accept payloads, references may be made to portions of the `requestBody` or the entire body. |
| Request URL            | `$url` | |
| Response value         | `$response.body#/status` | In operations which return payloads, references may be made to portions of the response body or the entire body. |
| Response header        | `$response.header.Server` | Single header values only are available. |
| Workflow input         | `$inputs.username` or `$workflows.foo.inputs.username` | Single input values only are available. |
| Step output value      | `$steps.someStep.pets` | In situations where the output named property return payloads, references may be made to portions of the response body or the entire body. |
| Workflow output value  | `$outputs.bar` or `$workflows.foo.outputs.bar` | Single input values only are available. |
| Components parameter   | `$components.parameters.foo` | Accesses a foo parameter defined within the Components Object. |

Runtime expressions preserve the type of the referenced value. Expressions can be embedded into string values by surrounding the expression with `{}` curly braces.

## Arazzo Runtime Expression Syntax

Arazzo 1.0.1 [ABNF](https://datatracker.ietf.org/doc/html/rfc5234) 
Syntax is defined using the following syntax:

````abnf
expression = ( "$url" / "$method" / "$statusCode" / "$request." source / "$response." source / "$inputs." name / "$outputs." name / "$steps." name / "$workflows." name / "$sourceDescriptions." name / "$components." name / "$components.parameters." parameter-name)
parameter-name = name ; Reuses 'name' rule for parameter names
source = ( header-reference / query-reference / path-reference / body-reference )
header-reference = "header." token
query-reference = "query." name
path-reference = "path." name
body-reference = "body" ["#" json-pointer ]
json-pointer    = *( "/" reference-token )
reference-token = *( unescaped / escaped )
unescaped       = %x00-2E / %x30-7D / %x7F-10FFFF
   ; %x2F ('/') and %x7E ('~') are excluded from 'unescaped'
escaped         = "~" ( "0" / "1" )
  ; representing '~' and '/', respectively
name = *( CHAR )
token = 1*tchar
tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
  "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
````

However, while implementing the lexer and 
[AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)
to parse them, I found it better to redefine some rules to
make it easier to validate the expression. The following
syntax is the one used to defined the parser:

````abnf
expression = (expression-single / expression-with-source / expression-with-name)
expression-single = ( "$url" / "$method" / "$statusCode" )
expression-with-source = ("$request." source / "$response." source)
expression-with-name = ("$inputs." name / "$outputs." name / "$steps." name / "$workflows." name / "$sourceDescriptions." name / "$components." name / "$components.parameters." parameter-name)
parameter-name = name ; Reuses 'name' rule for parameter names
source = ( header-reference / query-reference / path-reference / body-reference )
header-reference = "header." token
query-reference = "query." name
path-reference = "path." name
body-reference = "body" ["#" json-pointer ]
json-pointer    = *( "/" reference-token )
reference-token = *( unescaped / escaped )
unescaped       = %x00-2E / %x30-7D / %x7F-10FFFF
    ; %x2F ('/') and %x7E ('~') are excluded from 'unescaped'
escaped         = "~" ( "0" / "1" )
    ; representing '~' and '/', respectively
name = *( CHAR )
token = 1*tchar
tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
  "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
CHAR =  %x01-7F
    ; any 7-bit US-ASCII character,
    ;  excluding NUL
DIGIT =  %x30-39
    ; 0-9
ALPHA =  %x41-5A / %x61-7A   
    ; A-Z / a-z
````

## Contributing

Contributions are welcome! Please see the [CONTRIBUTING.md](../../CONTRIBUTING.md) file for guidelines on how to contribute.

## License

This project is licensed under the MIT License. See the [LICENSE](../../LICENSE) file for details.